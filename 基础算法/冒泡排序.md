# 冒泡排序

冒泡排序是一种基础的排序算法，通过重复比较相邻元素并交换位置来实现排序。以下是代码实现和详细解析：

#### 1. 基本实现（无优化）
```javascript
function bubbleSort(arr) {
  const n = arr.length;
  // 外层循环：控制比较轮数（需要 n-1 轮）
  for (let i = 0; i < n - 1; i++) {
    // 内层循环：比较相邻元素
    for (let j = 0; j < n - 1 - i; j++) {
      // 前 > 后时交换位置（升序）
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // ES6解构赋值交换
      }
    }
  }
  return arr;
}

// 使用示例
console.log(bubbleSort([5, 3, 8, 4, 2])); // [2, 3, 4, 5, 8]
```

#### 2. 优化版本（提前终止）
```javascript
function optimizedBubbleSort(arr) {
  const n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    let swapped = false; // 标记是否发生交换
    
    for (let j = 0; j < n - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        swapped = true; // 标记发生交换
      }
    }
    
    // 本轮未交换 → 已有序 → 提前结束
    if (!swapped) break;
  }
  return arr;
}

// 测试已排序数组（效率提升）
console.log(optimizedBubbleSort([1, 2, 3, 4, 5])); // 只需1轮遍历
```

---

### 核心解析
| **关键点**         | **说明**                                                                 |
|--------------------|--------------------------------------------------------------------------|
| **时间复杂度**     | 最差/平均：O(n²) <br> 最优（已排序）：O(n)（优化版本）                   |
| **空间复杂度**     | O(1)（原地排序）                                                         |
| **排序方向控制**   | 修改比较符：`>` 升序，`<` 降序                                          |
| **交换原理**       | `[a, b] = [b, a]` 利用ES6解构赋值实现简洁交换                            |
| **优化核心**       | `swapped` 标志位检测提前结束                                             |

---

### 算法流程演示（以 `[5, 3, 8, 4]` 为例）
1. **第一轮遍历**：
   - 比较 5>3 → 交换 → `[3, 5, 8, 4]`
   - 比较 5<8 → 保持
   - 比较 8>4 → 交换 → `[3, 5, 4, 8]`
   
2. **第二轮遍历**：
   - 比较 3<5 → 保持
   - 比较 5>4 → 交换 → `[3, 4, 5, 8]`
   - 检查到无交换 → 提前终止

---

### 实际应用场景
- **小规模数据排序**：浏览器端处理 <1000 条数据
- **教育目的**：理解排序算法基础原理
- **特殊需求**：需要稳定排序（相等元素不改变顺序）

> **注意**：大数据量场景请使用更高效算法（如快速排序、归并排序），冒泡排序在大数据量下性能较差。